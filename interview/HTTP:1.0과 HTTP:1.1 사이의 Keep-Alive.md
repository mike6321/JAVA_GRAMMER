HTTP/1.0과 HTTP/1.1의 가장 큰 차이는 지속 가능한 연결(keep-alive)을 명시적으로 선언해야 하는가에 있다.

이에 대한 내용을 차근차근히 살펴보자! 

> 웹 초창기에는 다수의 TCP 연결에 대한 고려가 필요 없었다. 사이트에 콘텐츠 수가 그리 많지 않았기 때문이다.
>
> 하지만 기술력이 발전하면서 사이트에 콘텐츠 수가 증가하게 되었고 클라이언트와 서버 간의 요청과 응답이 어떻게 하면 빠르게 이루어질 수 있을까에 대한 연구가 진행되었다.

### HTTP/1.0과 HTTP/1.1 사이의 Keep-Alive

HTTP/1.0 이후에 클라이언트와 서버 간의 요청과 응답을 어떻게 하면 빠르게 할 수 있을까에 대한 연구가 진행되었다.

대표적으로 아래의 두 가지 기법이 존재한다.

- **keep-Alive**
- **Pipelining**


HTTP/1.0 초기에는 클라이언트와 서버 간의 요청의 **3-way handshake**로 이루어졌다.

3-way handshake는 syn, syn-ack, ack로 이루어진다.



![img](https://k.kakaocdn.net/dn/DjCWE/btqDzkM05A8/kB7WKP1nWA9YxxumsIJ440/img.png)


예를 들어 10개의 오브젝트를 가진 웹 페이지가 존재한다면

클라이언트와 서버 사이에 10번의 3-way handshake 과정을 통해 TCP 연결을 맺고 끊는 과정을 반복해야 한다.

 

 

 

 

 

 

 

 

 

HTTP/1.0 기반에서 Persistence Connection을 원하고 이를 지원하는 클라이언트는 서버에게 HTTP 요청 시 아래와 같은 메시지를 헤더에 추가하면 Keep-Alive가 생성된다.

> connection:keep-alive

 

Persistence 커넥션을 지원하는 서버는 클라이언트의 요청을 수용하고 응답 이전까지 TCP 연결을 끊지 않는다.

이때 응답 헤더에도 동일한 헤더를 응답 메시지에 포함시킨다.

------

### HTTP1.1에서도 Keep-Alive를 헤더에 포함시켜야 하는가?

> 답은 그럴 수도 있고 아닐 수도 있다 이다.

 

이것의 의미는 HTTP/1.1은 기본적으로 Persistence 커넥션을 지원한다. 

만약 응답이후에 TCP 연결을 끊어야 하는 경우에만 해당 헤더를 선언한다. 

### 유의사항

모든 페이지에 Persistence 커넥션을 사용하면 서버 자원을 고갈시키기 때문에 사용할지 말지를 고려해 보아야 한다.

 

Keep-Alive를 사용하면서 얻을 수 있는 장점은 단일 시간 내의 TCP 연결을 최소화 함으로써 CPU와 메모리 자원을 절약할 수 있고 네트워크 혼잡이나 Latency에 대한 경우의 수를 줄일 수 있다는 점이다.

 

또한 Keep-Alive는 복수개의 HTTP 요청과 응답을 병렬적으로 동시에 처리하기 위한 HTTP 파이프라이닝 기술을 사용하기 위해서는 꼭 지원되어야 한다.



출처: https://jwdeveloper.tistory.com/222 [JW- 개발일지]

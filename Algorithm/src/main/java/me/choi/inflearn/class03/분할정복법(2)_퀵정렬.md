# 분할정복법(2) (Dived and Conquer) - 퀵 정렬

> 합병절렬이 반으로 구분하였던 것과 달리 pivot을 설정하여 구분한다.
>
> 합병정렬과 무엇이 다른가를 묻는다면 퀵정렬은 합병정렬과 달리 합병 단계가 존재하지 않는다.

### partition이 제일 중요하다!

------

partition은 통상적으로 맨 마지막 배열의 값으로 한다.

## partitioning의 방법

* 마지막 값을 pivot으로 정한다.
* 배열의 앞 부터 쭈욱 비교를 시작한다.
* 비교만하면 의미가 없는 작업이기에 아래의 기준을 새기면서 정렬한다.
  * **pivot 보다 작은 값의 마지막 인덱스** 
  * **pivot 보다 큰 값의 첫번째 인덱스**



> * 가장 앞에 있는 값을 pivot 값으로 설정
>
> * -> 왼쪽에서 오른쪽으로 이동 : pivot 보다 큰값을 설정
>
> * <- 오른쪽에서 왼쪽으로 이동 : pivot 보다 작은 값을 설정
> * 큰 값 과 작은 값을 swap
> * 큰 값의 인덱스가 작은 값의 인덱스 보다 작을 떄 까지 반복 (엇갈릴때까지)
>   * 작은 값과 pivot를 swap

**3 7 8 1 5 9 6 10 2 4**

[3] 7 8 1 5 9 6 10 2 4   : 3 pivot 설정

[3] <7> 8 1 5 9 6 10 <2> 4    :  pivot 보다 큰 값 : 7 pivot 보다 작은 값 : 2

[3] <2> 8 1 5 9 6 10 <7> 4    : swap

[3] 2 <8> <1> 5 9 6 10 7 4

[3] 2 <1> <8> 5 9 6 10 7 4

[3] 2 <1> <8> 5 9 6 10 7 4    : 엇갈렸다!

<1> 2 [3] <8> 5 9 6 10 7 4	: 작은 값과 pivot swap

1 2 **3** 8 5 9 6 10 7 4    : 3 왼쪽은 다 작고 3 오른쪽은 다 크다

[1] 2 **3** 8 5 9 6 10 7 4    : 1, 8 pivot 설정 (정렬된 3은 이제 배제하고 정렬한다)

... 이러한 식으로 계속 정렬

 

## 시간복잡도

평균 속도 : O(N log N)

왜냐면 1 2 3 4 5 6 7 8 9 10 를 예로들면

선택정렬을 한다고치면 O(N^2) 이므로 10^2 = 100이다



이것을 반반으로 쪼갠다면

1 2 3 4 5    

5^2 = 25

6 7 8 9 10 

5^2 = 25

25 + 25 = 50 이므로 기본적인 선택정렬보다 2배가 빠르다는 것을 볼 수 있다.












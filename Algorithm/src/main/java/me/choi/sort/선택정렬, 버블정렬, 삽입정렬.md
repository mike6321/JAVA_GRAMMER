# 정렬

------



## **선택정렬**

> * 배열 중 가장 큰 값을 찾아서 가장 마지막으로 옮겨간다.
>   * 마지막에 옮긴 값은 이제 정렬 대상이 아니다.
> * 두 개의 배열이 남을 때까지 이러한 과정을 반복한다.
>

29 10 14 37 13

29 10 14 **[37]** 13

29 10 14 13 <37>

**[29]** 10 14 13 <37>

13 10 14 <29 37>

13 10  **[14]** <29 37>

13 10 <14 29 37>

**[13]** 10 <14 29 37>

10 <13 14 29 37>

**10 13 14 29 37**



#### **시간복잡도**

1 2 3 4 5 6 7 8 9 10

10 - 1을 앞으로 보내기 위한 탐색 횟수

2 3 4 5 6 7 8 9 10

9 - 2를 앞으로 보내기 위한 탐색 횟수

3 4 5 6 7 8 9 10

8 - 3을 앞으로 보내기 위한 탐색 횟수

...

10 + 9 + 8 + 7 + ... + 1 = 10 * (10 + 1) / 2 = 55

수행 시간 : N * (N + 1) / 2 

**결과 : N * N = O(N^2)**

------

## 버블정렬

 선택정렬과 유사

29 10 14 37 13

[29 10] 14 37 13

[10 29] 14 37 13

10 [29 14] 37 13

10 [14 29] 37 13

10 14 [29 37] 13

10 14 29 [37 13]

10 14 29 [13 37]

10 14 29 13 <**37**>

......

**10 13 14 29 37**



#### **시간복잡도**

* T(n) = T(n-1) + T(n-2) + T(n-3) ... + 2 + 1

10 + 9 + 8 + 7 + ... + 1 = 10 * (10 + 1) / 2 = 55

수행 시간 : N * (N + 1) / 2 

**결과 : N * N = O(N^2)**

------

## 삽입정렬

* 맨 앞의 데이터는 이미 정렬되어 있다. (너무 자명한 소리)
* 거기에 뒤에 있는 데이터를 삽입해서 비교 
  * 삽입한 데이터가 앞의 데이터 보다 크면 swap
* 이러한 과정을 반복하면 앞의 데이터는 자연스럽게 정렬되어있다.

29 10 14 37 13

**[29]** 10 14 37 13

<**[29]** 10> 14 37 13

<10 29> 14 37 13

<10 29> **[14]** 37 13

<10 **[14]** 29>  37 13

<10 14 29>  **[37]** 13

<10 14 29  **[37]**> 13

<10 14 29  37 **[13]**>

<10 13 14 29  37>

**10 13 14 29  37**

하지만 이때 생각해볼것이 삽입되어야할 데이터가 원하는 위치에 들어갈 위치를 찾아야한다.

* 앞에서 찾는것이 효율적일까 뒤에서 찾는것이 효율적일까?
  * 답은 뒤에서 찾는것이다!

이유는 앞에서 찾는다면 찾은다음 뒤에 있는 데이터를 뒤로 다 밀어야한다.

뒤에처 찾는다면 찾은 다음 앞에 있는 데이터는 이미 정렬되어있으니 손댈 필요가 없기 때문이다.

### 	또한 뒤에서 찾는다면 비교를 함과 동시에 shift가 가능하기 때문이다.

시간복잡도 : 

- 최선의 경우 : 1 - 한번만 비교할때 (삽입 시 한번만 비교하면 되니깐) 
- 최악의 경우 : O(n^2) 

